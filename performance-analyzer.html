<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Performance Analyzer - Dynamic Gaussian Rendering</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            color: #937EE2;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #888;
            margin-bottom: 30px;
        }

        .upload-section {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            border: 1px solid #3a3a3a;
        }

        .upload-area {
            border: 2px dashed #555;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #1f1f1f;
        }

        .upload-area:hover {
            border-color: #937EE2;
            background: #252525;
        }

        .upload-area.dragover {
            border-color: #937EE2;
            background: #2a1f3a;
        }

        input[type="file"] {
            display: none;
        }

        .btn {
            background: #937EE2;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        .btn:hover {
            background: #7a6bb8;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #3a3a3a;
        }

        .stat-label {
            color: #888;
            font-size: 12px;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .stat-value {
            color: #937EE2;
            font-size: 24px;
            font-weight: bold;
        }

        .stat-unit {
            color: #666;
            font-size: 14px;
            margin-left: 4px;
        }

        .chart-container {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            border: 1px solid #3a3a3a;
        }

        .chart-title {
            color: #e0e0e0;
            margin-bottom: 15px;
            font-size: 18px;
        }

        .table-container {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            border: 1px solid #3a3a3a;
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #3a3a3a;
        }

        th {
            color: #937EE2;
            font-weight: 600;
            position: sticky;
            top: 0;
            background: #2a2a2a;
        }

        td {
            color: #ccc;
        }

        tr:hover {
            background: #333;
        }

        .metric-name {
            color: #937EE2;
            font-weight: 500;
        }

        .no-data {
            text-align: center;
            color: #666;
            padding: 40px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #3a3a3a;
        }

        .tab {
            padding: 10px 20px;
            cursor: pointer;
            color: #888;
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
            transition: all 0.3s;
        }

        .tab.active {
            color: #937EE2;
            border-bottom-color: #937EE2;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .bottleneck-analysis {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #3a3a3a;
            margin-bottom: 30px;
        }

        .bottleneck-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            margin-bottom: 10px;
            background: #1f1f1f;
            border-radius: 6px;
            border-left: 4px solid #937EE2;
        }

        .bottleneck-label {
            color: #e0e0e0;
            font-weight: 500;
        }

        .bottleneck-value {
            color: #937EE2;
            font-size: 18px;
            font-weight: bold;
        }

        .bottleneck-percentage {
            color: #888;
            font-size: 14px;
            margin-left: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìä Performance Analyzer</h1>
        <p class="subtitle">Dynamic Gaussian Rendering Performance Analysis Tool</p>

        <div class="upload-section">
            <div class="upload-area" id="uploadArea">
                <p style="margin-bottom: 10px; color: #ccc;">üìÅ ÊãñÊãΩ JSON Êñá‰ª∂Âà∞ËøôÈáåÔºåÊàñÁÇπÂáªÈÄâÊã©Êñá‰ª∂</p>
                <button class="btn" onclick="document.getElementById('fileInput').click()">ÈÄâÊã©Êñá‰ª∂</button>
                <input type="file" id="fileInput" accept=".json">
            </div>
        </div>

        <div id="analysisContent" style="display: none;">
            <div class="tabs">
                <div class="tab active" onclick="switchTab('overview')">Ê¶ÇËßà</div>
                <div class="tab" onclick="switchTab('timeline')">Êó∂Èó¥Â∫èÂàó</div>
                <div class="tab" onclick="switchTab('distribution')">ÂàÜÂ∏É</div>
                <div class="tab" onclick="switchTab('raw')">ÂéüÂßãÊï∞ÊçÆ</div>
            </div>

            <div id="overview" class="tab-content active">
                <div class="bottleneck-analysis">
                    <h2 style="color: #937EE2; margin-bottom: 15px;">ÊÄßËÉΩÁì∂È¢àÂàÜÊûê</h2>
                    <div id="bottleneckList"></div>
                </div>

                <div class="stats-grid" id="statsGrid"></div>

                <div class="chart-container">
                    <div class="chart-title">ÂêÑÈò∂ÊÆµÂπ≥ÂùáËÄóÊó∂ÂØπÊØî</div>
                    <canvas id="avgChart"></canvas>
                </div>
            </div>

            <div id="timeline" class="tab-content">
                <div class="chart-container">
                    <div class="chart-title">Â∏ßÊó∂Èó¥Â∫èÂàó - ÊÄªÂ∏ßÊó∂Èó¥</div>
                    <canvas id="totalFrameChart"></canvas>
                </div>
                <div class="chart-container">
                    <div class="chart-title">ÂêÑÈò∂ÊÆµËÄóÊó∂Êó∂Èó¥Â∫èÂàó</div>
                    <canvas id="timelineChart"></canvas>
                </div>
            </div>

            <div id="distribution" class="tab-content">
                <div class="chart-container">
                    <div class="chart-title">ÊÄªÂ∏ßÊó∂Èó¥ÂàÜÂ∏É</div>
                    <canvas id="distributionChart"></canvas>
                </div>
            </div>

            <div id="raw" class="tab-content">
                <div class="table-container">
                    <table id="dataTable">
                        <thead>
                            <tr>
                                <th>Frame</th>
                                <th>Position Calc (ms)</th>
                                <th>Sorting (ms)</th>
                                <th>GPU Render (ms)</th>
                                <th>Pre-Render (ms)</th>
                                <th>Post-Render (ms)</th>
                                <th>Total Frame (ms)</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>
        </div>

        <div id="noData" class="no-data">
            <p>ËØ∑‰∏ä‰º†ÊÄßËÉΩÊï∞ÊçÆ JSON Êñá‰ª∂ÂºÄÂßãÂàÜÊûê</p>
        </div>
    </div>

    <script>
        let performanceData = [];
        let charts = {};

        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const analysisContent = document.getElementById('analysisContent');
        const noData = document.getElementById('noData');

        // File upload handlers
        uploadArea.addEventListener('click', (e) => {
            // Don't trigger if clicking the button (button has its own handler)
            if (e.target.tagName !== 'BUTTON') {
                fileInput.click();
            }
        });
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && file.type === 'application/json') {
                loadFile(file);
            }
        });

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                loadFile(file);
                // Reset file input value so the same file can be selected again
                e.target.value = '';
            }
        });

        function loadFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    performanceData = JSON.parse(e.target.result);
                    analyzeData();
                } catch (error) {
                    alert('Ëß£Êûê JSON Êñá‰ª∂Â§±Ë¥•: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        function analyzeData() {
            if (performanceData.length === 0) {
                noData.style.display = 'block';
                analysisContent.style.display = 'none';
                return;
            }

            noData.style.display = 'none';
            analysisContent.style.display = 'block';

            // Calculate statistics
            const stats = calculateStats();
            displayStats(stats);
            displayBottleneckAnalysis(stats);
            createCharts(stats);
            displayRawData();
        }

        function calculateStats() {
            const metrics = ['positionCalculation', 'sorting', 'gpuRender', 'preRender', 'postRender', 'totalFrame'];
            const stats = {};

            metrics.forEach(metric => {
                let values = performanceData.map(d => d[metric]).filter(v => v !== undefined);
                
                // Special handling for sorting: filter out 0 values (skipped frames)
                if (metric === 'sorting') {
                    const originalCount = values.length;
                    values = values.filter(v => v > 0);
                    stats[metric] = {
                        skippedFrames: originalCount - values.length,
                        totalFrames: originalCount
                    };
                }
                
                if (values.length === 0) return;

                values.sort((a, b) => a - b);
                const sum = values.reduce((a, b) => a + b, 0);
                const avg = sum / values.length;
                const min = values[0];
                const max = values[values.length - 1];
                const p95 = values[Math.floor(values.length * 0.95)];

                // Merge with existing stats (for sorting metric)
                stats[metric] = {
                    ...stats[metric],
                    avg, min, max, p95,
                    values,
                    sum
                };
            });

            return stats;
        }

        function displayStats(stats) {
            const grid = document.getElementById('statsGrid');
            grid.innerHTML = '';

            const metricNames = {
                positionCalculation: '‰ΩçÁΩÆËÆ°ÁÆó',
                sorting: 'ÊéíÂ∫è',
                gpuRender: 'GPUÊ∏≤Êüì',
                preRender: 'È¢ÑÂ§ÑÁêÜ',
                postRender: 'ÂêéÂ§ÑÁêÜ',
                totalFrame: 'ÊÄªÂ∏ßÊó∂Èó¥'
            };

            Object.keys(stats).forEach(metric => {
                const stat = stats[metric];
                const card = document.createElement('div');
                card.className = 'stat-card';
                
                let extraInfo = `Min: ${stat.min.toFixed(2)}ms | Max: ${stat.max.toFixed(2)}ms | P95: ${stat.p95.toFixed(2)}ms`;
                
                // Add skipped frame info for sorting metric
                if (metric === 'sorting' && stat.skippedFrames !== undefined) {
                    extraInfo += `<br><span style="color: #FF6B6B;">‚ö†Ô∏è ${stat.skippedFrames} Â∏ßË¢´Ë∑≥Ëøá (${(stat.skippedFrames / stat.totalFrames * 100).toFixed(1)}%)</span>`;
                }
                
                card.innerHTML = `
                    <div class="stat-label">${metricNames[metric]}</div>
                    <div>
                        <span class="stat-value">${stat.avg.toFixed(2)}</span>
                        <span class="stat-unit">ms</span>
                    </div>
                    <div style="margin-top: 10px; font-size: 12px; color: #666;">
                        ${extraInfo}
                    </div>
                `;
                grid.appendChild(card);
            });
        }

        function displayBottleneckAnalysis(stats) {
            const list = document.getElementById('bottleneckList');
            list.innerHTML = '';

            if (!stats.totalFrame) return;

            const totalAvg = stats.totalFrame.avg;
            const metrics = [
                { key: 'positionCalculation', name: '‰ΩçÁΩÆËÆ°ÁÆó' },
                { key: 'sorting', name: 'ÊéíÂ∫è' },
                { key: 'gpuRender', name: 'GPUÊ∏≤Êüì' },
                { key: 'preRender', name: 'È¢ÑÂ§ÑÁêÜ' },
                { key: 'postRender', name: 'ÂêéÂ§ÑÁêÜ' }
            ];

            const items = metrics
                .filter(m => stats[m.key])
                .map(m => ({
                    name: m.name,
                    avg: stats[m.key].avg,
                    percentage: (stats[m.key].avg / totalAvg * 100)
                }))
                .sort((a, b) => b.percentage - a.percentage);

            items.forEach(item => {
                const div = document.createElement('div');
                div.className = 'bottleneck-item';
                div.innerHTML = `
                    <span class="bottleneck-label">${item.name}</span>
                    <div>
                        <span class="bottleneck-value">${item.avg.toFixed(2)}ms</span>
                        <span class="bottleneck-percentage">(${item.percentage.toFixed(1)}%)</span>
                    </div>
                `;
                list.appendChild(div);
            });
        }

        function createCharts(stats) {
            // Destroy existing charts
            Object.values(charts).forEach(chart => chart.destroy());
            charts = {};

            // Average comparison chart
            const avgCtx = document.getElementById('avgChart').getContext('2d');
            const metricNames = {
                positionCalculation: '‰ΩçÁΩÆËÆ°ÁÆó',
                sorting: 'ÊéíÂ∫è',
                gpuRender: 'GPUÊ∏≤Êüì',
                preRender: 'È¢ÑÂ§ÑÁêÜ',
                postRender: 'ÂêéÂ§ÑÁêÜ'
            };

            const avgData = Object.keys(metricNames)
                .filter(key => stats[key])
                .map(key => ({
                    label: metricNames[key],
                    value: stats[key].avg
                }));

            charts.avg = new Chart(avgCtx, {
                type: 'bar',
                data: {
                    labels: avgData.map(d => d.label),
                    datasets: [{
                        label: 'Âπ≥ÂùáËÄóÊó∂ (ms)',
                        data: avgData.map(d => d.value),
                        backgroundColor: '#937EE2',
                        borderColor: '#7a6bb8',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => `${context.parsed.y.toFixed(2)}ms`
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: { color: '#888' },
                            grid: { color: '#3a3a3a' }
                        },
                        x: {
                            ticks: { color: '#888' },
                            grid: { color: '#3a3a3a' }
                        }
                    }
                }
            });

            // Total frame time timeline
            const totalCtx = document.getElementById('totalFrameChart').getContext('2d');
            charts.total = new Chart(totalCtx, {
                type: 'line',
                data: {
                    labels: performanceData.map((_, i) => i),
                    datasets: [{
                        label: 'ÊÄªÂ∏ßÊó∂Èó¥ (ms)',
                        data: performanceData.map(d => d.totalFrame),
                        borderColor: '#937EE2',
                        backgroundColor: 'rgba(147, 126, 226, 0.1)',
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { labels: { color: '#888' } },
                        tooltip: {
                            callbacks: {
                                label: (context) => `Frame ${context.dataIndex}: ${context.parsed.y.toFixed(2)}ms`
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: { color: '#888' },
                            grid: { color: '#3a3a3a' }
                        },
                        x: {
                            ticks: { color: '#888' },
                            grid: { color: '#3a3a3a' },
                            title: { display: true, text: 'Frame', color: '#888' }
                        }
                    }
                }
            });

            // Timeline chart for all metrics
            const timelineCtx = document.getElementById('timelineChart').getContext('2d');
            const colors = {
                positionCalculation: '#FF6B6B',
                sorting: '#4ECDC4',
                gpuRender: '#45B7D1',
                preRender: '#FFA07A',
                postRender: '#98D8C8'
            };

            charts.timeline = new Chart(timelineCtx, {
                type: 'line',
                data: {
                    labels: performanceData.map((_, i) => i),
                    datasets: Object.keys(metricNames)
                        .filter(key => stats[key])
                        .map(key => ({
                            label: metricNames[key],
                            data: performanceData.map(d => d[key] || 0),
                            borderColor: colors[key] || '#937EE2',
                            backgroundColor: 'transparent',
                            tension: 0.4,
                            fill: false
                        }))
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { labels: { color: '#888' } },
                        tooltip: {
                            callbacks: {
                                label: (context) => `${context.dataset.label}: ${context.parsed.y.toFixed(2)}ms`
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: { color: '#888' },
                            grid: { color: '#3a3a3a' }
                        },
                        x: {
                            ticks: { color: '#888' },
                            grid: { color: '#3a3a3a' },
                            title: { display: true, text: 'Frame', color: '#888' }
                        }
                    }
                }
            });

            // Distribution chart
            const distCtx = document.getElementById('distributionChart').getContext('2d');
            const totalFrameValues = performanceData.map(d => d.totalFrame);
            const bins = createBins(totalFrameValues, 20);
            
            charts.distribution = new Chart(distCtx, {
                type: 'bar',
                data: {
                    labels: bins.map(b => `${b.min.toFixed(1)}-${b.max.toFixed(1)}`),
                    datasets: [{
                        label: 'Â∏ßÊï∞',
                        data: bins.map(b => b.count),
                        backgroundColor: '#937EE2',
                        borderColor: '#7a6bb8',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { labels: { color: '#888' } },
                        tooltip: {
                            callbacks: {
                                label: (context) => `${context.parsed.y} Â∏ß`
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: { color: '#888', stepSize: 1 },
                            grid: { color: '#3a3a3a' }
                        },
                        x: {
                            ticks: { color: '#888', maxRotation: 45 },
                            grid: { color: '#3a3a3a' },
                            title: { display: true, text: 'ÊÄªÂ∏ßÊó∂Èó¥ (ms)', color: '#888' }
                        }
                    }
                }
            });
        }

        function createBins(values, numBins) {
            const min = Math.min(...values);
            const max = Math.max(...values);
            const binSize = (max - min) / numBins;
            const bins = Array(numBins).fill(0).map((_, i) => ({
                min: min + i * binSize,
                max: min + (i + 1) * binSize,
                count: 0
            }));

            values.forEach(value => {
                const binIndex = Math.min(Math.floor((value - min) / binSize), numBins - 1);
                bins[binIndex].count++;
            });

            return bins;
        }

        function displayRawData() {
            const tbody = document.querySelector('#dataTable tbody');
            tbody.innerHTML = '';

            performanceData.forEach((row, index) => {
                const tr = document.createElement('tr');
                
                // Highlight rows where sorting was skipped
                const sortingCell = row.sorting === 0 
                    ? `<td style="color: #FF6B6B; font-weight: bold;">${row.sorting.toFixed(2)} (Ë∑≥Ëøá)</td>`
                    : `<td>${row.sorting.toFixed(2)}</td>`;
                
                tr.innerHTML = `
                    <td>${row.frame}</td>
                    <td>${row.positionCalculation.toFixed(2)}</td>
                    ${sortingCell}
                    <td>${row.gpuRender.toFixed(2)}</td>
                    <td>${row.preRender.toFixed(2)}</td>
                    <td>${row.postRender.toFixed(2)}</td>
                    <td>${row.totalFrame.toFixed(2)}</td>
                `;
                tbody.appendChild(tr);
            });
        }

        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
        }
    </script>
</body>
</html>
